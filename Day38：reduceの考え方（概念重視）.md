
## 1.今回の学習の説明（まず概念だけ）


reduceとは何か？

配列を
「1つの値にまとめる」ための考え方

ここで大事なのは
**「何にまとめたいかを先に決める」**ことです。


例（結果のイメージだけ）

数の配列 → 合計の数値

文字列の配列 → 1つの文章

オブジェクトの配列 → 集計結果のオブジェクト

👉 map / filter と違い、
reduceは「最終結果が1つ」になるのが特徴です。

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

## 2.基本の書き方（最小限）


まず形だけ見ます。

配列.reduce((acc, current) => {
  return 次のacc;
}, 初期値);


ここでの役割

・acc（アキュムレータ）

途中結果（たまっていく箱）


・current

今見ている配列の1要素


・初期値

accの最初の中身




**超シンプルな例（合計）**

const numbers = [1, 2, 3];

const sum = numbers.reduce((acc, num) => {
  return acc + num;
}, 0);


流れ（重要）

acc = 0（初期値）
↓
acc = 0 + 1
↓
acc = 1 + 2
↓
acc = 3 + 3
↓
最後に 6 が返る

👉 「回す」ではなく「積み上げる」感覚

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

// 文字列を1つにまとめる
["a", "b", "c"].reduce((acc, s) => acc + s, "");



// 完了したAction数を数える
actions.reduce((acc, a) => acc + (a.done ? 1 : 0), 0);

done=true,falseの結果で、true=1,false=0として累計する。



// Dreamごとのアクション進捗を集計する

[
  { dreamId: "dream1" },
  { dreamId: "dream1" },
  { dreamId: "dream2" }
]
↑これを累計する

actions.reduce((acc, a) => {
  acc[a.dreamId] = (acc[a.dreamId] || 0) + 1;
  return acc;
}, {});

acc[a.dreamId]はaccがa.dreamIdを見に行く。
その上で(acc[a.dreamId] || 0) + 1;は見に行き、あったらその分+1、なかったら0として数え、その結果を出すために累計する。

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

📘 Day38：reduce の考え方（完全まとめ）


■ 今日学んだこと（核心）

reduce は、配列を最終的に1つの結果にまとめるためのもの

結果は 数値・文字列・オブジェクト など何でもよい

map / filter と違い、必ず「1つ」になる



■ 基本の形


配列.reduce((acc, current) => {
  return 次のacc;
}, 初期値);


acc：途中までの結果（箱）

current：今見ている要素

初期値：箱の最初の中身（0 / "" / {} など）



■ 代表例

① 合計を出す

numbers.reduce((acc, n) => acc + n, 0);

→ 数値を 累計して1つの数にする



② 条件付きで数える

actions.reduce((acc, a) => acc + (a.done ? 1 : 0), 0);

→ true を 1、false を 0 として 件数を数える



③ Dreamごとに Action 数を集計

actions.reduce((acc, a) => {
  acc[a.dreamId] = (acc[a.dreamId] || 0) + 1;
  return acc;
}, {});

■ ここで一番大事だった疑問と答え

Q. acc[a.dreamId] は何をしている？
A.
👉 その dreamId に紐づく Action が、今までに何個あったかを見に行っている

Q. なぜ || 0 が必要？
A.
👉 まだその dreamId が出てきていない場合、
undefined + 1 を防ぐため、0 から数え始めるため

Q. 「あったら / なかったら」の正確な意味は？
A.

初登場の dreamId → 0 + 1

2回目以降の dreamId → 今までの数 + 1



■ 今日の最終結論（これだけ覚えればOK）

reduce とは、配列を最終的に1つの集計結果にまとめるためのもの