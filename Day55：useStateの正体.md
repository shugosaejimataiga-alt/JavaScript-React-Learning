📘 Day55まとめ（useStateの正体）


① まず理解したこと

コンポーネントは関数

再描画＝コンポーネント関数が最初から再実行される

普通の変数は再実行でリセットされる



② 問題

let count = 0;
count = 1;

Reactはこの変更を知らない
ただの変数変更は無視される
再描画は起きない



③ useStateの構造


const [count, setCount] = useState(0);


内部構造（概念）：

[現在の値, 状態変更用の関数]

つまり

count → 状態の値
setCount → Reactに通知する関数



④ 関数は「値」

function宣言も関数式も本質は同じ

関数も代入できる
配列にも入れられる
実行しなくても「関数という値」



⑤ setCountが重要な理由


setCount(1);

内部で起きること：

状態を更新
Reactに通知
コンポーネント再実行
仮想DOM再構築
差分だけ更新



🔥 今日の核心

useStateの本質は

👉 「値」ではなく「通知機構」



🧠 最重要フレーズ

Reactは普通の変数を監視していない

set関数だけが再描画を引き起こす

再描画＝関数の再実行