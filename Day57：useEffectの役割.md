

✅ Day57 完全まとめ


① 再描画の復習

set〇〇が呼ばれる↓
Reactがコンポーネント関数を再実行↓
新しい仮想DOMを作る↓
前回と比較↓
差分だけ更新

👉 Reactは「画面を直接いじる」のではなく
👉 「データを変えて表示を再計算する思想」



② 問題点

コンポーネント関数の中に

console.log("API");

のような処理を書くと、

👉 再描画のたびに毎回実行される

これは困る。



③ useEffectの役割

👉 再描画の あとに 実行される
👉 表示とは別の処理（副作用）を書くための仕組み

副作用の例：

API通信
localStorage保存
タイマー
イベント登録

④ 基本パターン3種類


① 初回だけ

useEffect(() => {
  // 処理
}, []);


② 毎回

useEffect(() => {
  // 処理
});


③ 特定の値が変わった時だけ

useEffect(() => {
  // 処理
}, [count]);




⑤ 依存配列の本質

useEffectは

👉 依存配列の「値」を前回と比較する
👉 値が変わったら実行する

set〇〇を見ているわけではない。



🎯 今日の核心一文

useEffectは、
「再描画後に、依存値の変化を見て副作用を実行する仕組み」